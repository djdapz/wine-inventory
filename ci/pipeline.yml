---
resources:

- name: repo
  type: git
  source:
    uri: ((git-repo))
    private_key: ((github-private-key))

- name: openjdk
  type: docker-image
  source:
    repository: openjdk
    tag: 8

- name: postgres
  type: docker-image
  source:
    repository: postgres

- name: openjdk-node-cf
  type: docker-image
  source:
    repository: djdapz/openjdk-node-cf
    username: ((dockerhub-username))
    password: ((dockerhub-password))

- name: version
  type: semver
  source:
    driver: git
    uri: git@github.com:djdapz/wine-inventory.git
    branch: version
    file: version
    private_key: ((github-private-key))

jobs:

- name: run-tests-backend
  public: true
  plan:
  - get: version
  - get: repo
    trigger: true
  - get: openjdk
    params: {save: true}
  - get: postgres
    params: {save: true}
  - task: run-tests
    privileged: true
    config:
      platform: linux
      image_resource:
          type: docker-image
          source:
            repository: amidos/dcind
      run:
        path: sh
        args:
        - -exc
        - |
          source /docker-lib.sh
          source repo/ci/tasks/common.sh

          start_docker

          docker load -i postgres/image
          docker load -i openjdk-node-cf/image

          docker images

          # Run the container with tests and its dependencies.
          docker-compose -f repo/ci/docker-compose.tests.yml run unit-integration-tests

          # Cleanup.
          # Not sure if this is required.
          # It's quite possible that Concourse is smart enough to clean up the Docker mess itself.
          docker-compose -f repo/ci/docker-compose.tests.yml down
          docker volume rm $(docker volume ls -q)
  - put: version
    params: {bump: patch}

- name: build-and-upload-frontend
  public: true
  plan:
  - get: version
    trigger: true
    passed: ["run-tests-backend"]
  - get: repo
    trigger: true
    passed: ["run-tests-backend"]
  - get: openjdk-node-cf
    params: {save: true}
  - task: build-and-upload
    privileged: true
    image: openjdk-node-cf
    config:
      platform: linux
      run:
        path: sh
        args:
        - -exc
        - |
          #!/bin/bash

          set -ex

          export BUILD_VERSION=`cat version/number`

          pushd frontend
            npm install
            npm run build
          popd

          echo " >>>> Zipping Frontend"
          zip -r frontend.zip frontend
          echo " <<<< Frontend Zipped"

          echo " >>>> Uploading frontend-server.zip to aws"
          /root/bin/aws s3 cp "./frontend.zip" "s3://wine-inventory/app/frontend-{BUILD_VERSION}.zip"
          echo " <<<< Uploaded frontend-server.zip to aws"

      params:
        AWS_ACCESS_KEY_ID: ((AWS_ACCESS_KEY_ID))
        AWS_SECRET_ACCESS_KEY: ((AWS_SECRET_ACCESS_KEY))


- name: build-and-upload-backend
  public: true
  plan:
  - get: version
    trigger: true
    passed: ["run-tests-backend"]
  - get: repo
    trigger: true
    passed: ["run-tests-backend"]
  - get: openjdk-node-cf
    params: {save: true}
  - task: build-and-upload
    privileged: true
    image: openjdk-node-cf
    config:
      platform: linux
      run:
        path: sh
        args:
        - -exc
        - |
          #!/bin/bash

          set -ex

          export BUILD_VERSION=`cat version/number`

          pushd repo
            ./gradlew clean assemble -Pversion=$BUILD_VERSION
            echo " >>>> Uploading jar to aws"
            /root/bin/aws s3 cp "build/libs/wine-inventory-${BUILD_VERSION}.jar" "s3://wine-inventory/app/wine-inventory-${BUILD_VERSION}.jar"
            echo " <<<< Uploaded jar to aws"
          popd
      params:
        AWS_ACCESS_KEY_ID: ((AWS_ACCESS_KEY_ID))
        AWS_SECRET_ACCESS_KEY: ((AWS_SECRET_ACCESS_KEY))



